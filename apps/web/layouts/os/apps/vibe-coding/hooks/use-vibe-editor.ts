/**
 * useVibeEditorConvex Hook
 *
 * Main hook for the Vibe Code Editor that manages:
 * - Chat messages (fetching from Convex, displaying, sending)
 * - Streaming responses from the AI coding agent
 * - File artifacts generated by the agent
 *
 * Data Flow:
 * 1. User sends message ‚Üí handleSendMessage()
 * 2. Message saved to Convex ‚Üí streamFromAgent() starts
 * 3. SSE stream received ‚Üí callbacks update UI state in real-time
 *    - text-delta events are saved to Convex progressively (debounced)
 * 4. Stream completes ‚Üí final content saved to Convex (message + artifacts)
 * 5. Convex query auto-updates ‚Üí UI shows persisted messages
 */

import { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { useQuery, useMutation } from 'convex/react';
import { api } from '@/convex/_generated/api';
import { Id } from '@/convex/_generated/dataModel';
import { useStreamHandler } from './use-stream-handler';
import type { StreamCallbacks } from '../types/stream-types';

// Debounce interval for saving streaming content to Convex (ms)
const STREAMING_SAVE_DEBOUNCE_MS = 500;

export function useVibeEditorConvex(sessionId: string, initialMessage?: string) {
  // ============================================
  // STATE: UI Input & Streaming Status
  // ============================================
  const [inputMessage, setInputMessage] = useState(''); // Current text in input field
  const [isStreaming, setIsStreaming] = useState(false); // True while receiving SSE stream

  // ============================================
  // STATE: Real-time Streaming Content
  // These update as SSE chunks arrive from the agent
  // ============================================
  const [streamingContent, setStreamingContent] = useState(''); // Accumulated text response
  const [reasoningContent, setReasoningContent] = useState(''); // AI reasoning/thinking (if available)
  const [currentToolCall, setCurrentToolCall] = useState<string | null>(null); // Current tool being executed
  const [toolCallArgs, setToolCallArgs] = useState<Map<string, string>>(new Map()); // Tool arguments being streamed
  const [createdFiles, setCreatedFiles] = useState<string[]>([]); // List of files created by agent
  const [streamingFiles, setStreamingFiles] = useState<Map<string, string>>(new Map()); // Files content streamed in real-time

  // Activity log - tracks all streaming events for display
  const [activityLog, setActivityLog] = useState<
    Array<{
      id: string;
      type: 'tool-start' | 'tool-end' | 'file-created' | 'text' | 'thinking';
      message: string;
      timestamp: Date;
      filePath?: string;
    }>
  >([]);

  // Pending message - shown after streaming ends but before Convex updates
  const [pendingMessage, setPendingMessage] = useState<{
    content: string;
    files: string[];
    timestamp: Date;
  } | null>(null);

  // ============================================
  // REFS: DOM & Initialization Tracking
  // ============================================
  const scrollRef = useRef<HTMLDivElement>(null); // Anchor element for auto-scroll
  const hasInitialized = useRef(false); // Prevents double-firing of initial message

  // Stream handler hook for SSE communication
  const { streamFromAgent } = useStreamHandler();

  // ============================================
  // CONVEX: Real-time Database Queries
  // ============================================
  // Fetch messages for this chat session (auto-updates when data changes)
  const messagesQuery = useQuery(
    api.chat.getChatMessages,
    sessionId ? { sessionId: sessionId as Id<'chatSessions'> } : 'skip',
  );
  const messages = useMemo(() => messagesQuery || [], [messagesQuery]);
  const isLoadingMessages = messagesQuery === undefined;

  // Fetch latest artifact to merge new files with existing ones
  const latestArtifact = useQuery(
    api.vibeCoding.getLatestArtifact,
    sessionId ? { sessionId: sessionId as Id<'chatSessions'> } : 'skip',
  );

  // ============================================
  // CONVEX: Mutations for Persisting Data
  // ============================================
  const sendMessage = useMutation(api.vibeCoding.sendVibeCodeMessage); // Save user message
  const addAssistantMessage = useMutation(api.chat.addAssistantMessage); // Save AI response
  const createStreamingMessage = useMutation(api.chat.createStreamingMessage); // Create streaming message
  const updateStreamingMessage = useMutation(api.chat.updateStreamingMessage); // Update streaming content
  const saveArtifact = useMutation(api.vibeCoding.saveGeneratedArtifact); // Save generated files

  // ============================================
  // REFS: Streaming Message Tracking
  // ============================================
  const streamingMessageIdRef = useRef<Id<'chatMessages'> | null>(null);
  const lastSavedContentRef = useRef<string>('');
  const saveTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // ============================================
  // EFFECT: Auto-scroll to Latest Message
  // ============================================
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages.length, streamingContent]);

  // ============================================
  // CALLBACKS: Stream Event Handlers
  // These are called by the stream parser as SSE events arrive
  // Helper to add activity log entry
  const addActivity = useCallback(
    (
      type: 'tool-start' | 'tool-end' | 'file-created' | 'text' | 'thinking',
      message: string,
      filePath?: string,
    ) => {
      setActivityLog((prev) => [
        ...prev,
        {
          id: `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,
          type,
          message,
          timestamp: new Date(),
          filePath,
        },
      ]);
    },
    [],
  );

  // Track the file currently being created (for loading indicator in explorer)
  const [loadingFile, setLoadingFile] = useState<string | null>(null);

  // ============================================
  // HELPER: Save streaming content to Convex (debounced)
  // ============================================
  const saveStreamingContentToConvex = useCallback(
    async (content: string) => {
      if (!streamingMessageIdRef.current) return;
      if (content === lastSavedContentRef.current) return;

      try {
        await updateStreamingMessage({
          messageId: streamingMessageIdRef.current,
          content,
        });
        lastSavedContentRef.current = content;
        console.log('[Stream] Saved streaming content to Convex:', content.length, 'chars');
      } catch (error) {
        console.error('[Stream] Failed to save streaming content:', error);
      }
    },
    [updateStreamingMessage],
  );

  // ============================================
  // HELPER: Debounced save for streaming content
  // ============================================
  const debouncedSaveStreamingContent = useCallback(
    (content: string) => {
      // Clear any pending save
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }

      // Schedule a new save
      saveTimeoutRef.current = setTimeout(() => {
        saveStreamingContentToConvex(content);
      }, STREAMING_SAVE_DEBOUNCE_MS);
    },
    [saveStreamingContentToConvex],
  );

  // ============================================
  // HELPER: Build rich message content with activity log
  // ============================================
  const buildStreamingMessageContent = useCallback((
    textContent: string,
    currentActivity: string | null,
    files: string[],
    reasoning?: string,
  ) => {
    let message = '';
    
    // Add reasoning/thinking if available
    if (reasoning && reasoning.trim()) {
      message += `üí≠ **Thinking:**\n${reasoning}\n\n`;
    }
    
    // Add current activity
    if (currentActivity) {
      message += `‚öôÔ∏è ${currentActivity}\n\n`;
    }
    
    // Add text content
    if (textContent && textContent.trim()) {
      message += textContent;
    }
    
    // Add file list if files were created
    if (files.length > 0) {
      message += `\n\nüìÅ **Files Created:**\n`;
      files.forEach((file) => {
        message += `  ‚Ä¢ ${file}\n`;
      });
    }
    
    return message;
  }, []);

  // ============================================
  const createCallbacks = useCallback((): StreamCallbacks => ({
    // Called when text content is received (accumulated, not delta)
    onTextDelta: (content) => {
      console.log('[Stream] Text delta:', content.slice(-50));
      setStreamingContent(content);
      
      // Build rich message and save to Convex (debounced)
      const richContent = buildStreamingMessageContent(
        content,
        currentToolCall,
        createdFiles,
        reasoningContent,
      );
      debouncedSaveStreamingContent(richContent);
    },
    // Called when a tool starts executing
    onToolCall: (toolName) => {
      console.log('[Stream] Tool call:', toolName);
      setCurrentToolCall(toolName);
      if (toolName) {
        addActivity('tool-start', `Running ${toolName}...`);
        
        // Update Convex with current activity
        const richContent = buildStreamingMessageContent(
          streamingContent,
          `Running ${toolName}...`,
          createdFiles,
          reasoningContent,
        );
        debouncedSaveStreamingContent(richContent);
      }
      // Clear loading file when tool finishes
      if (!toolName) {
        setLoadingFile(null);
      }
    },
    // Called when tool arguments are being streamed
    onToolArgs: (args) => {
      console.log('[Stream] Tool args:', Object.fromEntries(args));
      setToolCallArgs(args);
      
      // Extract filePath from createFile tool args for loading indicator
      args.forEach((argsJson) => {
        try {
          const parsed = JSON.parse(argsJson);
          if (parsed.filePath) {
            setLoadingFile(parsed.filePath);
          }
        } catch {
          // Args still streaming, not valid JSON yet
        }
      });
    },
    // Called when AI reasoning/thinking content arrives
    onReasoning: (reasoning) => {
      console.log('[Stream] Reasoning:', reasoning.slice(-50));
      setReasoningContent(reasoning);
      
      // Update Convex with reasoning
      const richContent = buildStreamingMessageContent(
        streamingContent,
        currentToolCall,
        createdFiles,
        reasoning,
      );
      debouncedSaveStreamingContent(richContent);
    },
    // Called when files are created by the agent
    onFileCreated: (files) => {
      console.log('[Stream] Files created:', files);
      // Add activity for new files only
      const currentFiles = createdFiles;
      const newFiles = files.filter((f) => !currentFiles.includes(f));
      newFiles.forEach((file) => {
        addActivity('file-created', `Created ${file}`, file);
      });
      setCreatedFiles(files);
    },
    // Called when file content is available during streaming
    onFileContent: (filePath: string, content: string) => {
      console.log('[Stream] File content received:', filePath);
      setStreamingFiles((prev) => new Map(prev).set(filePath, content));
    },
    // Mastra file streaming callbacks
    onSessionStart: (streamSessionId: string) => {
      console.log('[Stream] Session start:', streamSessionId);
    },
    onFileStart: (fileId: string, path: string, fileName: string) => {
      console.log('[Stream] File start:', fileId, path, fileName);
      setLoadingFile(path);
      addActivity('tool-start', `Creating ${fileName}...`, path);
      
      // Update Convex with file creation activity
      const richContent = buildStreamingMessageContent(
        streamingContent,
        `Creating ${fileName}...`,
        createdFiles,
        reasoningContent,
      );
      debouncedSaveStreamingContent(richContent);
    },
    onFileChunk: (fileId: string, _chunk: string, chunkIndex: number, accumulated: string) => {
      console.log('[Stream] File chunk:', fileId, 'index:', chunkIndex, accumulated.length, 'chars total');
      // Update streaming files map for real-time editor display
      // Note: We'll get the path in onFileEnd
    },
    onFileEnd: (fileId: string, path: string, finalContent: string) => {
      console.log('[Stream] File end:', fileId, path, finalContent.length, 'chars');
      setLoadingFile(null);
      setStreamingFiles((prev) => new Map(prev).set(path, finalContent));
      
      // Update created files list
      const updatedFiles = [...createdFiles];
      if (!updatedFiles.includes(path)) {
        updatedFiles.push(path);
        setCreatedFiles(updatedFiles);
      }
      
      addActivity('file-created', `Created ${path}`, path);
      
      // Update Convex with completed file
      const richContent = buildStreamingMessageContent(
        streamingContent,
        null,
        updatedFiles,
        reasoningContent,
      );
      debouncedSaveStreamingContent(richContent);
    },
    onFileUrl: (fileId: string, path: string, url: string, expiresAt: string) => {
      console.log('[Stream] File URL:', fileId, path, url.slice(0, 50), 'expires:', expiresAt);
      // Could store URLs for download/preview functionality
    },
    onFileError: (fileId: string, error: string) => {
      console.error('[Stream] File error:', fileId, error);
      setLoadingFile(null);
    },
    onStreamingDone: (streamSessionId: string) => {
      console.log('[Stream] Streaming done:', streamSessionId);
    },
    onStreamingError: (error: string) => {
      console.error('[Stream] Streaming error:', error);
    },
  }), [
    addActivity,
    createdFiles,
    debouncedSaveStreamingContent,
    buildStreamingMessageContent,
    streamingContent,
    currentToolCall,
    reasoningContent,
  ]);

  // ============================================
  // HELPER: Reset All Streaming State
  // Called when stream ends (success or error)
  // ============================================
  const resetStreamState = useCallback(() => {
    setIsStreaming(false);
    setStreamingContent('');
    setReasoningContent('');
    setCurrentToolCall(null);
    setToolCallArgs(new Map());
    setCreatedFiles([]);
    setStreamingFiles(new Map());
    setActivityLog([]);
    setLoadingFile(null);
    // Clear streaming message refs
    streamingMessageIdRef.current = null;
    lastSavedContentRef.current = '';
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
      saveTimeoutRef.current = null;
    }
  }, []);

  // ============================================
  // HELPER: Persist Results to Convex
  // Saves assistant message and generated files after stream completes
  // Merges new files with existing artifact files
  // ============================================
  const saveResults = useCallback(
    async (
      content: string,
      newFiles: Map<string, string>,
      description: string,
    ) => {
      console.log('[saveResults] Saving results:', {
        contentLength: content?.length,
        contentPreview: content?.slice(0, 100),
        newFilesCount: newFiles.size,
        newFileNames: Array.from(newFiles.keys()),
        existingFilesCount: latestArtifact?.files ? Object.keys(latestArtifact.files).length : 0,
        streamingMessageId: streamingMessageIdRef.current,
      });

      // Merge new files with existing artifact files
      const mergedFiles = new Map<string, string>();
      
      // Add existing files first
      if (latestArtifact?.files) {
        const existingFiles = latestArtifact.files as Record<string, string>;
        Object.entries(existingFiles).forEach(([path, fileContent]) => {
          mergedFiles.set(path, fileContent);
        });
      }
      
      // Add/overwrite with new files
      newFiles.forEach((fileContent, path) => {
        mergedFiles.set(path, fileContent);
      });

      console.log('[saveResults] Merged files:', {
        totalFiles: mergedFiles.size,
        allFileNames: Array.from(mergedFiles.keys()),
      });

      // Build the full message content including file info
      let fullContent = content || '';
      const newFileNames = Array.from(newFiles.keys());
      
      // Append file creation summary if files were created
      if (newFiles.size > 0) {
        const fileList = newFileNames.map((f) => `  ‚Ä¢ ${f}`).join('\n');
        fullContent += `\n\nüìÅ **Files Created/Updated:**\n${fileList}`;
      }

      // Update the streaming message with final content (mark as complete)
      if (streamingMessageIdRef.current && fullContent?.trim()) {
        console.log('[saveResults] Updating streaming message with final content...');
        await updateStreamingMessage({
          messageId: streamingMessageIdRef.current,
          content: fullContent,
          isComplete: true,
        });
        console.log('[saveResults] Streaming message finalized!');
      } else if (fullContent?.trim()) {
        // Fallback: create new message if no streaming message exists
        console.log('[saveResults] Creating new assistant message (fallback)...');
        await addAssistantMessage({
          sessionId: sessionId as Id<'chatSessions'>,
          content: fullContent,
        });
        console.log('[saveResults] Assistant message saved!');
      } else {
        console.log('[saveResults] No content to save (empty or whitespace)');
        // Mark streaming message as complete even if empty
        if (streamingMessageIdRef.current) {
          await updateStreamingMessage({
            messageId: streamingMessageIdRef.current,
            content: '',
            isComplete: true,
          });
        }
      }

      // Save merged files as artifact (includes both old and new files)
      if (mergedFiles.size > 0) {
        console.log('[saveResults] Saving artifact with merged files...');
        const filesObject = Object.fromEntries(mergedFiles);
        console.log('[saveResults] Files to save:', {
          keys: Object.keys(filesObject),
          sampleContent: Object.values(filesObject)[0]?.slice(0, 100),
          allContentLengths: Object.entries(filesObject).map(([k, v]) => ({ [k]: v.length })),
        });
        await saveArtifact({
          sessionId: sessionId as Id<'chatSessions'>,
          name: 'Generated Code',
          description: description.slice(0, 100),
          files: JSON.stringify(filesObject),
          metadata: { framework: 'React', language: 'TypeScript' },
        });
        console.log('[saveResults] Artifact saved with', mergedFiles.size, 'files!');
      }
    },
    [sessionId, addAssistantMessage, updateStreamingMessage, saveArtifact, latestArtifact],
  );

  // ============================================
  // MAIN: Handle User Message Submission
  // ============================================
  const handleSendMessage = useCallback(
    async (message?: string, skipSaveMessage = false) => {
      const messageToSend = message || inputMessage.trim();
      console.log('[handleSendMessage] Starting:', {
        messageToSend,
        sessionId,
        isStreaming,
      });

      // Guard: Don't send if empty, no session, or already streaming
      if (!messageToSend || !sessionId || isStreaming) {
        console.log('[handleSendMessage] Blocked:', {
          noMessage: !messageToSend,
          noSession: !sessionId,
          alreadyStreaming: isStreaming,
        });
        return;
      }

      // Clear input and reset streaming state, then start streaming
      setInputMessage('');
      setStreamingContent('');
      setReasoningContent('');
      setCurrentToolCall(null);
      setToolCallArgs(new Map());
      setCreatedFiles([]);
      setStreamingFiles(new Map());
      setIsStreaming(true);
      console.log('[handleSendMessage] State reset, streaming started');

      try {
        // Step 1: Save user message to Convex (unless already saved)
        if (!skipSaveMessage) {
          console.log('[handleSendMessage] Saving user message to Convex...');
          await sendMessage({
            sessionId: sessionId as Id<'chatSessions'>,
            content: messageToSend,
          });
          console.log('[handleSendMessage] User message saved');
        }

        // Step 2: Create streaming message in Convex (for real-time updates)
        console.log('[handleSendMessage] Creating streaming message in Convex...');
        const streamingMsgId = await createStreamingMessage({
          sessionId: sessionId as Id<'chatSessions'>,
        });
        streamingMessageIdRef.current = streamingMsgId;
        lastSavedContentRef.current = '';
        console.log('[handleSendMessage] Streaming message created:', streamingMsgId);

        // Step 3: Stream response from AI agent
        console.log('[handleSendMessage] Starting stream from agent...');
        const { assistantContent, files } = await streamFromAgent(
          messageToSend,
          createCallbacks(),
        );

        console.log('[handleSendMessage] Stream complete:', {
          contentLength: assistantContent.length,
          filesCount: files.size,
          files: Array.from(files.keys()),
        });

        // Step 4: Finalize the streaming message with complete content
        await saveResults(assistantContent, files, messageToSend);
        console.log('[handleSendMessage] Results saved to Convex');
      } catch (error) {
        if (error instanceof Error && error.name === 'AbortError') {
          console.log('[handleSendMessage] Stream cancelled by user');
          // Mark streaming message as complete even if cancelled
          if (streamingMessageIdRef.current) {
            await updateStreamingMessage({
              messageId: streamingMessageIdRef.current,
              content: lastSavedContentRef.current || '[Stream cancelled]',
              isComplete: true,
            });
          }
        } else {
          console.error('[handleSendMessage] Stream error:', error);
          // Update streaming message with error
          if (streamingMessageIdRef.current) {
            await updateStreamingMessage({
              messageId: streamingMessageIdRef.current,
              content: `Error: ${error instanceof Error ? error.message : 'Failed to connect to coding agent'}`,
              isComplete: true,
            });
          } else {
            // Fallback: create new message for error
            await addAssistantMessage({
              sessionId: sessionId as Id<'chatSessions'>,
              content: `Error: ${error instanceof Error ? error.message : 'Failed to connect to coding agent'}`,
            });
          }
        }
      } finally {
        console.log('[handleSendMessage] Resetting stream state');
        resetStreamState();
      }
    },
    [
      sessionId,
      inputMessage,
      isStreaming,
      sendMessage,
      createStreamingMessage,
      updateStreamingMessage,
      streamFromAgent,
      createCallbacks,
      saveResults,
      resetStreamState,
      addAssistantMessage,
    ],
  );

  // ============================================
  // EFFECT: Auto-send Initial Message
  // When editor opens with an initialMessage, automatically start streaming
  // ============================================
  useEffect(() => {
    // Guard: Only run once, and only if we have an initial message
    if (!initialMessage || !sessionId || hasInitialized.current) return;

    hasInitialized.current = true;

    const triggerInitialStream = async () => {
      // Reset state and start streaming
      setStreamingContent('');
      setReasoningContent('');
      setCurrentToolCall(null);
      setCreatedFiles([]);
      setStreamingFiles(new Map());
      setIsStreaming(true);

      try {
        // Create streaming message in Convex for real-time updates
        console.log('[triggerInitialStream] Creating streaming message...');
        const streamingMsgId = await createStreamingMessage({
          sessionId: sessionId as Id<'chatSessions'>,
        });
        streamingMessageIdRef.current = streamingMsgId;
        lastSavedContentRef.current = '';
        console.log('[triggerInitialStream] Streaming message created:', streamingMsgId);

        // Stream from agent (message already saved during session creation)
        const { assistantContent, files } = await streamFromAgent(
          initialMessage,
          createCallbacks(),
        );

        // Save results to Convex
        await saveResults(assistantContent, files, initialMessage);
      } catch (error) {
        if (error instanceof Error && error.name !== 'AbortError') {
          console.error('Stream error:', error);
          // Update streaming message with error if it exists
          if (streamingMessageIdRef.current) {
            await updateStreamingMessage({
              messageId: streamingMessageIdRef.current,
              content: `Error: ${error instanceof Error ? error.message : 'Failed to connect to coding agent'}`,
              isComplete: true,
            });
          } else {
            await addAssistantMessage({
              sessionId: sessionId as Id<'chatSessions'>,
              content: `Error: ${error instanceof Error ? error.message : 'Failed to connect to coding agent'}`,
            });
          }
        }
      } finally {
        resetStreamState();
      }
    };

    triggerInitialStream();
  }, [
    initialMessage,
    sessionId,
    createStreamingMessage,
    updateStreamingMessage,
    streamFromAgent,
    createCallbacks,
    saveResults,
    resetStreamState,
    addAssistantMessage,
  ]);

  // ============================================
  // TRANSFORM: Convert Convex Messages to UI Format
  // Filter out empty messages, but keep streaming messages (even if empty)
  // ============================================
  const transformedMessages = useMemo(
    () =>
      messages
        .filter((msg) => (msg.content != null && msg.content !== '') || msg.isStreaming)
        .map((msg) => ({
          id: String(msg._id),
          role: msg.role as 'user' | 'assistant',
          content: msg.content,
          timestamp: new Date(msg.createdAt),
          isStreaming: msg.isStreaming,
        })),
    [messages],
  );

  // Clear pending message when Convex updates with the new message
  useEffect(() => {
    if (pendingMessage && messages.length > 0) {
      // Check if the last message from Convex matches our pending message
      const lastMessage = messages[messages.length - 1];
      if (lastMessage?.role === 'assistant') {
        console.log('[useVibeEditorConvex] Clearing pending message - Convex updated');
        setPendingMessage(null);
      }
    }
  }, [messages, pendingMessage]);

  // Debug: Log messages when they change
  useEffect(() => {
    console.log('[useVibeEditorConvex] Messages updated:', {
      rawCount: messages.length,
      transformedCount: transformedMessages.length,
      hasPendingMessage: !!pendingMessage,
      messages: transformedMessages.map((m) => ({
        role: m.role,
        contentPreview: m.content.slice(0, 50),
      })),
    });
  }, [messages.length, transformedMessages, pendingMessage]);

  // ============================================
  // COMBINE: Messages with pending message
  // ============================================
  const allMessages = pendingMessage
    ? [
        ...transformedMessages,
        {
          id: 'pending-' + Date.now(),
          role: 'assistant' as const,
          content: pendingMessage.content,
          timestamp: pendingMessage.timestamp,
        },
      ]
    : transformedMessages;

  // ============================================
  // RETURN: Expose State & Actions to Components
  // ============================================
  return {
    // Persisted messages from Convex (+ pending message if any)
    messages: allMessages,
    isLoadingMessages,

    // Input state
    inputMessage,
    setInputMessage,

    // Streaming state (for real-time UI updates)
    isStreaming,
    streamingContent,
    reasoningContent,
    currentToolCall,
    toolCallArgs,
    createdFiles,
    streamingFiles,
    activityLog,
    loadingFile,

    // DOM ref for auto-scroll
    scrollRef,

    // Actions
    handleSendMessage,
  };
}
